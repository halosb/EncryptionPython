#!/usr/bin/env python3
import sys,os,time,datetime,hashlib,base64,getpass,urllib.request,subprocess,uuid

# save original sys.exit and provide a cross-platform 'press any key' wait
sys_exit_orig = sys.exit
def _wait_any_key(prompt='按任意键退出...'):
    try:
        import msvcrt
        msvcrt.getch()
        return
    except Exception:
        pass
    try:
        import tty,termios,sys as _sys
        fd = _sys.stdin.fileno()
        old = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            _sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)
        return
    except Exception:
        pass
    try:
        input(prompt)
    except Exception:
        pass

def terminate(msg, code=1):
    print(msg)
    try:
        if sys.stdin is not None and sys.stdin.isatty():
            _wait_any_key('按任意键退出...')
    except Exception:
        pass
    try:
        sys_exit_orig(code)
    except Exception:
        pass

# redirect sys.exit to terminate so console stays open for messages
sys.exit = lambda code=1: terminate('', code)

SALT_HEX='ef7285515f1ece67827a721dd3a6ab1b'
EXPECTED_HASH='1aa5a8b1cfbbe43d8fffe44165be83f6f5280631c7f0082ebf0793ef78fb12f1'
INTEGRITY='6e2d6fd0ea2ccfb74e4dcc1c5d641c1445c870cee9b36a27cf9177af8fccf359'
LOCK_THRESHOLD=5
LOCK_MINUTES=10
PAYLOAD_B64='aW1wb3J0IHN5cw0KaW1wb3J0IG9zDQppbXBvcnQgcmVxdWVzdHMNCmltcG9ydCBqc29uDQppbXBvcnQgcmUNCmZyb20gUHlRdDUuUXRXaWRnZXRzIGltcG9ydCAoUUFwcGxpY2F0aW9uLCBRTWFpbldpbmRvdywgUVdpZGdldCwgUVZCb3hMYXlvdXQsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRSEJveExheW91dCwgUVB1c2hCdXR0b24sIFFMYWJlbCwgUVNsaWRlciwgUUxpc3RXaWRnZXQsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRRmlsZURpYWxvZywgUVN0YWNrZWRXaWRnZXQsIFFDb2xvckRpYWxvZywgUU1lc3NhZ2VCb3gsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFFGcmFtZSwgUVNwbGl0dGVyLCBRU3R5bGUsIFFHcmFwaGljc0JsdXJFZmZlY3QsIFFBY3Rpb24sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFFEaWFsb2csIFFMaW5lRWRpdCwgUVRleHRFZGl0LCBRQ2hlY2tCb3gsIFFGb250RGlhbG9nKQ0KZnJvbSBQeVF0NS5RdENvcmUgaW1wb3J0IFF0LCBRVXJsLCBRVGltZXIsIFFUaHJlYWQsIHB5cXRTaWduYWwsIFFTaXplLCBRUG9pbnQsIFFQcm9wZXJ0eUFuaW1hdGlvbiwgUUVhc2luZ0N1cnZlDQpmcm9tIFB5UXQ1LlF0R3VpIGltcG9ydCBRSWNvbiwgUUNvbG9yLCBRUGFsZXR0ZSwgUUZvbnQsIFFQaXhtYXAsIFFQYWludGVyLCBRQnJ1c2gsIFFJbWFnZQ0KZnJvbSBQeVF0NS5RdE11bHRpbWVkaWEgaW1wb3J0IFFNZWRpYVBsYXllciwgUU1lZGlhQ29udGVudA0KZnJvbSBQeVF0NS5RdE11bHRpbWVkaWFXaWRnZXRzIGltcG9ydCBRVmlkZW9XaWRnZXQNCg0KIyAtLS0gQ29uc3RhbnRzICYgQ29uZmlnIC0tLQ0KREVGQVVMVF9QTEFZTElTVF9JRCA9ICIyOTIwNjQ3NTM3Ig0KQVBJX0JBU0UgPSAiaHR0cHM6Ly9hcGkucWlqaWV5YS5jbi9tZXRpbmcvIg0KUkVRVUVTVF9IRUFERVJTID0gew0KICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMTYgU2FmYXJpLzUzNy4zNicsDQogICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9tdXNpYy4xNjMuY29tJywNCn0NClJFUVVFU1RfVElNRU9VVCA9IDEwDQoNCiMgLS0tIFdvcmtlcnMgLS0tDQpjbGFzcyBBcGlXb3JrZXIoUVRocmVhZCk6DQogICAgZmluaXNoZWQgPSBweXF0U2lnbmFsKGxpc3QsIHN0cikNCiAgICBlcnJvciA9IHB5cXRTaWduYWwoc3RyKQ0KICAgIA0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCBhcGlfdXJsLCBzZXJ2ZXI9Im5ldGVhc2UiLCBwbGF5bGlzdF9pZD0iIiwgcGFyZW50PU5vbmUpOg0KICAgICAgICBzdXBlcigpLl9faW5pdF9fKHBhcmVudCkNCiAgICAgICAgc2VsZi5hcGlfdXJsID0gYXBpX3VybA0KICAgICAgICBzZWxmLnNlcnZlciA9IHNlcnZlcg0KICAgICAgICBzZWxmLnBsYXlsaXN0X2lkID0gcGxheWxpc3RfaWQNCiAgICAgICAgDQogICAgZGVmIHJ1bihzZWxmKToNCiAgICAgICAgdHJhY2tzID0gW10NCiAgICAgICAgcGxheWxpc3RfbmFtZSA9ICLkupHnq6/ng63mrYwiDQogICAgICAgIHRyeToNCiAgICAgICAgICAgICMgMS4gRmV0Y2ggVHJhY2tzDQogICAgICAgICAgICByZXNwID0gcmVxdWVzdHMuZ2V0KHNlbGYuYXBpX3VybCwgaGVhZGVycz1SRVFVRVNUX0hFQURFUlMsIHRpbWVvdXQ9UkVRVUVTVF9USU1FT1VUKQ0KICAgICAgICAgICAgZGF0YSA9IHJlc3AuanNvbigpDQogICAgICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkYXRhLCBsaXN0KToNCiAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdDQogICAgICAgICAgICB0cmFja3MgPSBkYXRhDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgMi4gRmV0Y2ggUGxheWxpc3QgTmFtZSAoT25seSBmb3IgTmV0ZWFzZSkNCiAgICAgICAgICAgIGlmIHNlbGYuc2VydmVyID09ICJuZXRlYXNlIiBhbmQgc2VsZi5wbGF5bGlzdF9pZDoNCiAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgIGluZm9fdXJsID0gZiJodHRwOi8vbXVzaWMuMTYzLmNvbS9hcGkvcGxheWxpc3QvZGV0YWlsP2lkPXtzZWxmLnBsYXlsaXN0X2lkfSINCiAgICAgICAgICAgICAgICAgICAgaW5mb19yZXNwID0gcmVxdWVzdHMuZ2V0KGluZm9fdXJsLCBoZWFkZXJzPVJFUVVFU1RfSEVBREVSUywgdGltZW91dD1SRVFVRVNUX1RJTUVPVVQpDQogICAgICAgICAgICAgICAgICAgIGluZm9fZGF0YSA9IGluZm9fcmVzcC5qc29uKCkNCiAgICAgICAgICAgICAgICAgICAgaWYgJ3Jlc3VsdCcgaW4gaW5mb19kYXRhIGFuZCAnbmFtZScgaW4gaW5mb19kYXRhWydyZXN1bHQnXToNCiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0X25hbWUgPSBpbmZvX2RhdGFbJ3Jlc3VsdCddWyduYW1lJ10NCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3IuZW1pdChmIuiOt+WPluatjOWNleS/oeaBr+Wksei0pToge2V9IikNCiAgICAgICAgICAgICAgICAgICAgDQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgIHNlbGYuZXJyb3IuZW1pdChmIkFQSSDor7fmsYLlpLHotKU6IHtlfSIpDQogICAgICAgICAgICANCiAgICAgICAgc2VsZi5maW5pc2hlZC5lbWl0KHRyYWNrcywgcGxheWxpc3RfbmFtZSkNCg0KY2xhc3MgTHlyaWNzV29ya2VyKFFUaHJlYWQpOg0KICAgIGZpbmlzaGVkID0gcHlxdFNpZ25hbChzdHIsIHN0cikgIyB0cmFja19pZCwgbHlyaWNzX3RleHQNCiAgICBlcnJvciA9IHB5cXRTaWduYWwoc3RyKQ0KICAgIA0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCB0cmFjaywgcGFyZW50PU5vbmUpOg0KICAgICAgICBzdXBlcigpLl9faW5pdF9fKHBhcmVudCkNCiAgICAgICAgc2VsZi50cmFjayA9IHRyYWNrDQogICAgICAgIA0KICAgIGRlZiBydW4oc2VsZik6DQogICAgICAgIGxyY190ZXh0ID0gIiINCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgaWYgc2VsZi50cmFjay5nZXQoJ2xyYycpIGFuZCBub3Qgc2VsZi50cmFja1snbHJjJ10uc3RhcnRzd2l0aCgnaHR0cCcpIGFuZCBsZW4oc2VsZi50cmFja1snbHJjJ10pID4gMTA6DQogICAgICAgICAgICAgICAgbHJjX3RleHQgPSBzZWxmLnRyYWNrWydscmMnXQ0KICAgICAgICAgICAgZWxpZiBzZWxmLnRyYWNrLmdldCgnbHJjJykgYW5kIHNlbGYudHJhY2tbJ2xyYyddLnN0YXJ0c3dpdGgoJ2h0dHAnKToNCiAgICAgICAgICAgICAgICByZXNwID0gcmVxdWVzdHMuZ2V0KHNlbGYudHJhY2tbJ2xyYyddLCBoZWFkZXJzPVJFUVVFU1RfSEVBREVSUywgdGltZW91dD1SRVFVRVNUX1RJTUVPVVQpDQogICAgICAgICAgICAgICAgbHJjX3RleHQgPSByZXNwLnRleHQNCiAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgdHJhY2tfaWQgPSBzZWxmLnRyYWNrLmdldCgnaWQnKSBvciBzZWxmLnRyYWNrLmdldCgncGF0aCcpDQogICAgICAgICAgICAgICAgdXJsID0gZiJ7QVBJX0JBU0V9P3NlcnZlcj1uZXRlYXNlJnR5cGU9bHJjJmlkPXtzZWxmLnRyYWNrLmdldCgnaWQnKX0iDQogICAgICAgICAgICAgICAgcmVzcCA9IHJlcXVlc3RzLmdldCh1cmwsIGhlYWRlcnM9UkVRVUVTVF9IRUFERVJTLCB0aW1lb3V0PVJFUVVFU1RfVElNRU9VVCkNCiAgICAgICAgICAgICAgICBkYXRhID0gcmVzcC5qc29uKCkNCiAgICAgICAgICAgICAgICBscmNfdGV4dCA9IGRhdGEuZ2V0KCdseXJpYycsICcnKQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICBzZWxmLmVycm9yLmVtaXQoZiLmrYzor43liqDovb3lpLHotKU6IHtlfSIpDQogICAgICAgICAgICBscmNfdGV4dCA9ICJbMDA6MDAuMDBdIOatjOivjeWKoOi9veWksei0pSINCiAgICAgICAgICAgIA0KICAgICAgICAjIGVtaXQgYSByZWxpYWJsZSBpZGVudGlmaWVyOiBwcmVmZXIgaWQsIHRoZW4gcGF0aCwgdGhlbiBuYW1lDQogICAgICAgIGlkZW50ID0gc2VsZi50cmFjay5nZXQoJ2lkJykgb3Igc2VsZi50cmFjay5nZXQoJ3BhdGgnKSBvciBzZWxmLnRyYWNrLmdldCgnbmFtZScpDQogICAgICAgIHNlbGYuZmluaXNoZWQuZW1pdChzdHIoaWRlbnQpLCBscmNfdGV4dCkNCg0KY2xhc3MgSW1hZ2VXb3JrZXIoUVRocmVhZCk6DQogICAgZmluaXNoZWQgPSBweXF0U2lnbmFsKFFJbWFnZSkNCiAgICBlcnJvciA9IHB5cXRTaWduYWwoc3RyKQ0KICAgIA0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCB1cmwsIHBhcmVudD1Ob25lKToNCiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYXJlbnQpDQogICAgICAgIHNlbGYudXJsID0gdXJsDQogICAgICAgIA0KICAgIGRlZiBydW4oc2VsZik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGlmIHNlbGYudXJsOg0KICAgICAgICAgICAgICAgIHJlc3AgPSByZXF1ZXN0cy5nZXQoc2VsZi51cmwsIGhlYWRlcnM9UkVRVUVTVF9IRUFERVJTLCB0aW1lb3V0PVJFUVVFU1RfVElNRU9VVCkNCiAgICAgICAgICAgICAgICBkYXRhID0gcmVzcC5jb250ZW50DQogICAgICAgICAgICAgICAgaW1hZ2UgPSBRSW1hZ2UoKQ0KICAgICAgICAgICAgICAgIGltYWdlLmxvYWRGcm9tRGF0YShkYXRhKQ0KICAgICAgICAgICAgICAgIHNlbGYuZmluaXNoZWQuZW1pdChpbWFnZSkNCiAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgc2VsZi5maW5pc2hlZC5lbWl0KFFJbWFnZSgpKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBzZWxmLmVycm9yLmVtaXQoIuWwgemdouWKoOi9veWksei0pSIpDQogICAgICAgICAgICBzZWxmLmZpbmlzaGVkLmVtaXQoUUltYWdlKCkpDQoNCiMgLS0tIEN1c3RvbSBUaXRsZSBCYXIgLS0tDQpjbGFzcyBUaXRsZUJhcihRV2lkZ2V0KToNCiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyZW50KToNCiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYXJlbnQpDQogICAgICAgIHNlbGYuc2V0Rml4ZWRIZWlnaHQoNDApDQogICAgICAgIGxheW91dCA9IFFIQm94TGF5b3V0KHNlbGYpDQogICAgICAgIGxheW91dC5zZXRDb250ZW50c01hcmdpbnMoMTAsIDAsIDEwLCAwKQ0KICAgICAgICANCiAgICAgICAgc2VsZi50aXRsZV9sYWJlbCA9IFFMYWJlbCgiTXVzaWMgUGxheWVyIikNCiAgICAgICAgc2VsZi50aXRsZV9sYWJlbC5zZXRTdHlsZVNoZWV0KCJjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiBib2xkOyIpDQogICAgICAgIA0KICAgICAgICAjIFNldHRpbmdzIGJ1dHRvbiBsZWZ0IG9mIG1pbmltaXplDQogICAgICAgIHNlbGYuYnRuX3NldHRpbmdzID0gUVB1c2hCdXR0b24oIuKamSIpDQogICAgICAgIHNlbGYuYnRuX21pbiA9IFFQdXNoQnV0dG9uKCLvvI0iKQ0KICAgICAgICBzZWxmLmJ0bl9jbG9zZSA9IFFQdXNoQnV0dG9uKCLinJUiKQ0KICAgICAgICANCiAgICAgICAgZm9yIGJ0biBpbiBbc2VsZi5idG5fc2V0dGluZ3MsIHNlbGYuYnRuX21pbiwgc2VsZi5idG5fY2xvc2VdOg0KICAgICAgICAgICAgYnRuLnNldEZpeGVkU2l6ZSgzMCwgMzApDQogICAgICAgICAgICBidG4uc2V0U3R5bGVTaGVldCgiIiINCiAgICAgICAgICAgICAgICBRUHVzaEJ1dHRvbiB7IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyBjb2xvcjogd2hpdGU7IGJvcmRlcjogbm9uZTsgZm9udC1zaXplOiAxNHB4OyB9DQogICAgICAgICAgICAgICAgUVB1c2hCdXR0b246aG92ZXIgeyBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuMik7IGJvcmRlci1yYWRpdXM6IDE1cHg7IH0NCiAgICAgICAgICAgICIiIikNCiAgICAgICAgICAgIA0KICAgICAgICBzZWxmLmJ0bl9jbG9zZS5zZXRTdHlsZVNoZWV0KHNlbGYuYnRuX2Nsb3NlLnN0eWxlU2hlZXQoKS5yZXBsYWNlKCJob3ZlciB7IiwgImhvdmVyIHsgYmFja2dyb3VuZDogI2ZmNDQ0NDsiKSkNCg0KICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KHNlbGYudGl0bGVfbGFiZWwpDQogICAgICAgIGxheW91dC5hZGRTdHJldGNoKCkNCiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChzZWxmLmJ0bl9zZXR0aW5ncykNCiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChzZWxmLmJ0bl9taW4pDQogICAgICAgIGxheW91dC5hZGRXaWRnZXQoc2VsZi5idG5fY2xvc2UpDQogICAgICAgIA0KICAgICAgICAjIGNvbm5lY3Qgc2FmZWx5IHRvIHRvcC1sZXZlbCB3aW5kb3cgbWV0aG9kcw0KICAgICAgICBzZWxmLmJ0bl9zZXR0aW5ncy5jbGlja2VkLmNvbm5lY3QobGFtYmRhOiBnZXRhdHRyKHNlbGYud2luZG93KCksICdvcGVuX3NldHRpbmdzJywgbGFtYmRhOiBOb25lKSgpKQ0KICAgICAgICBzZWxmLmJ0bl9taW4uY2xpY2tlZC5jb25uZWN0KHBhcmVudC5zaG93TWluaW1pemVkKQ0KICAgICAgICBzZWxmLmJ0bl9jbG9zZS5jbGlja2VkLmNvbm5lY3QocGFyZW50LmNsb3NlKQ0KDQogICAgZGVmIG1vdXNlUHJlc3NFdmVudChzZWxmLCBldmVudCk6DQogICAgICAgIGlmIGV2ZW50LmJ1dHRvbigpID09IFF0LkxlZnRCdXR0b246DQogICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgdyA9IHNlbGYud2luZG93KCkNCiAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKHcsICd3aW5kb3dfc3RhcnRfbW92ZScpOg0KICAgICAgICAgICAgICAgICAgICB3LndpbmRvd19zdGFydF9tb3ZlKGV2ZW50Lmdsb2JhbFBvcygpKQ0KICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgICAgICAgICBwYXNzDQoNCiAgICBkZWYgbW91c2VNb3ZlRXZlbnQoc2VsZiwgZXZlbnQpOg0KICAgICAgICBpZiBldmVudC5idXR0b25zKCkgJiBRdC5MZWZ0QnV0dG9uOg0KICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgIHcgPSBzZWxmLndpbmRvdygpDQogICAgICAgICAgICAgICAgaWYgaGFzYXR0cih3LCAnd2luZG93X2RvX21vdmUnKToNCiAgICAgICAgICAgICAgICAgICAgdy53aW5kb3dfZG9fbW92ZShldmVudC5nbG9iYWxQb3MoKSkNCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgICAgICAgICAgcGFzcw0KDQogICAgZGVmIG1vdXNlUmVsZWFzZUV2ZW50KHNlbGYsIGV2ZW50KToNCiAgICAgICAgcmV0dXJuIHN1cGVyKCkubW91c2VSZWxlYXNlRXZlbnQoZXZlbnQpDQoNCg0KY2xhc3MgU2V0dGluZ3NEaWFsb2coUURpYWxvZyk6DQogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmVudD1Ob25lKToNCiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYXJlbnQpDQogICAgICAgIHNlbGYuc2V0V2luZG93VGl0bGUoIuiuvue9riIpDQogICAgICAgIHNlbGYucmVzaXplKDUwMCwgNDAwKQ0KICAgICAgICBzZWxmLnBhcmVudCA9IHBhcmVudA0KDQogICAgICAgIGxheW91dCA9IFFWQm94TGF5b3V0KHNlbGYpDQoNCiAgICAgICAgIyBQbGF5bGlzdCBJRA0KICAgICAgICBzZWxmLmxlX3BsYXlsaXN0ID0gUUxpbmVFZGl0KCkNCiAgICAgICAgc2VsZi5sZV9wbGF5bGlzdC5zZXRQbGFjZWhvbGRlclRleHQoIuatjOWNlUlE77yI55WZ56m65L2/55So6buY6K6k77yJIikNCiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChRTGFiZWwoIuatjOWNlUlE77yI55WZ56m66KGo56S65L2/55So6buY6K6k77yJ77yaIikpDQogICAgICAgIGxheW91dC5hZGRXaWRnZXQoc2VsZi5sZV9wbGF5bGlzdCkNCg0KICAgICAgICAjIEx5cmljcyBvcHRpb25zDQogICAgICAgIHNlbGYuYnRuX2ZvbnQgPSBRUHVzaEJ1dHRvbigi6YCJ5oup5q2M6K+N5a2X5L2TIikNCiAgICAgICAgc2VsZi5idG5fY29sb3IgPSBRUHVzaEJ1dHRvbigi6YCJ5oup5q2M6K+N6aKc6ImyIikNCiAgICAgICAgc2VsZi5jYl9wZXJjaGFyID0gUUNoZWNrQm94KCLpgJDlrZflkIzmraXvvIjlvIDlkK/lkI7lj6/og73pnIDopoHmrYzor43mlK/mjIHvvIkiKQ0KICAgICAgICBoID0gUUhCb3hMYXlvdXQoKQ0KICAgICAgICBoLmFkZFdpZGdldChzZWxmLmJ0bl9mb250KQ0KICAgICAgICBoLmFkZFdpZGdldChzZWxmLmJ0bl9jb2xvcikNCiAgICAgICAgbGF5b3V0LmFkZExheW91dChoKQ0KICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KHNlbGYuY2JfcGVyY2hhcikNCg0KICAgICAgICAjIExvZyB2aWV3ZXINCiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChRTGFiZWwoIuaXpeW/l++8miIpKQ0KICAgICAgICBzZWxmLnR4X2xvZyA9IFFUZXh0RWRpdCgpDQogICAgICAgIHNlbGYudHhfbG9nLnNldFJlYWRPbmx5KFRydWUpDQogICAgICAgIGxheW91dC5hZGRXaWRnZXQoc2VsZi50eF9sb2cpDQoNCiAgICAgICAgIyBCdXR0b25zDQogICAgICAgIGJfaCA9IFFIQm94TGF5b3V0KCkNCiAgICAgICAgc2VsZi5idG5fb2sgPSBRUHVzaEJ1dHRvbigi56Gu5a6aIikNCiAgICAgICAgc2VsZi5idG5fY2FuY2VsID0gUVB1c2hCdXR0b24oIuWPlua2iCIpDQogICAgICAgIGJfaC5hZGRTdHJldGNoKCkNCiAgICAgICAgYl9oLmFkZFdpZGdldChzZWxmLmJ0bl9vaykNCiAgICAgICAgYl9oLmFkZFdpZGdldChzZWxmLmJ0bl9jYW5jZWwpDQogICAgICAgIGxheW91dC5hZGRMYXlvdXQoYl9oKQ0KDQogICAgICAgIHNlbGYuYnRuX2NhbmNlbC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5yZWplY3QpDQogICAgICAgIHNlbGYuYnRuX29rLmNsaWNrZWQuY29ubmVjdChzZWxmLmFjY2VwdCkNCiAgICAgICAgc2VsZi5idG5fZm9udC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5jaG9vc2VfZm9udCkNCiAgICAgICAgc2VsZi5idG5fY29sb3IuY2xpY2tlZC5jb25uZWN0KHNlbGYuY2hvb3NlX2NvbG9yKQ0KDQogICAgZGVmIGNob29zZV9mb250KHNlbGYpOg0KICAgICAgICBmLCBvayA9IFFGb250RGlhbG9nLmdldEZvbnQoc2VsZi5wYXJlbnQubHlyaWNzX2ZvbnQsIHNlbGYpDQogICAgICAgIGlmIG9rOg0KICAgICAgICAgICAgc2VsZi5wYXJlbnQubHlyaWNzX2ZvbnQgPSBmDQoNCiAgICBkZWYgY2hvb3NlX2NvbG9yKHNlbGYpOg0KICAgICAgICBjID0gUUNvbG9yRGlhbG9nLmdldENvbG9yKHNlbGYucGFyZW50Lmx5cmljc19jb2xvciwgc2VsZikNCiAgICAgICAgaWYgYy5pc1ZhbGlkKCk6DQogICAgICAgICAgICBzZWxmLnBhcmVudC5seXJpY3NfY29sb3IgPSBjDQoNCiAgICBkZWYgZXhlY18oc2VsZik6DQogICAgICAgICMgcG9wdWxhdGUgZmllbGRzDQogICAgICAgIGlmIGdldGF0dHIoc2VsZi5wYXJlbnQsICdjdXJyZW50X3BsYXlsaXN0X2lkJywgREVGQVVMVF9QTEFZTElTVF9JRCkgPT0gREVGQVVMVF9QTEFZTElTVF9JRDoNCiAgICAgICAgICAgIHNlbGYubGVfcGxheWxpc3Quc2V0VGV4dCgiIikNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHNlbGYubGVfcGxheWxpc3Quc2V0VGV4dChzdHIoc2VsZi5wYXJlbnQuY3VycmVudF9wbGF5bGlzdF9pZCkpDQogICAgICAgIHNlbGYuY2JfcGVyY2hhci5zZXRDaGVja2VkKHNlbGYucGFyZW50LnBlcl9jaGFyX3N5bmMpDQogICAgICAgICMgbG9ncw0KICAgICAgICBzZWxmLnR4X2xvZy5zZXRQbGFpblRleHQoJ1xuJy5qb2luKHNlbGYucGFyZW50LmxvZ19saW5lc1stMjAwOl0pKQ0KICAgICAgICByZXR1cm4gc3VwZXIoKS5leGVjXygpDQoNCiMgLS0tIE1haW4gUGxheWVyIENsYXNzIC0tLQ0KY2xhc3MgTXVzaWNQbGF5ZXIoUU1haW5XaW5kb3cpOg0KICAgIGRlZiBfX2luaXRfXyhzZWxmKToNCiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpDQogICAgICAgIHNlbGYuc2V0V2luZG93VGl0bGUoIk11c2ljIFBsYXllciBQcm8iKQ0KICAgICAgICBzZWxmLnJlc2l6ZSgxMDAwLCA3MDApDQogICAgICAgIA0KICAgICAgICAjIEZyYW1lbGVzcyAmIFRyYW5zbHVjZW50DQogICAgICAgIHNlbGYuc2V0V2luZG93RmxhZ3MoUXQuRnJhbWVsZXNzV2luZG93SGludCB8IFF0LldpbmRvdykNCiAgICAgICAgc2VsZi5zZXRBdHRyaWJ1dGUoUXQuV0FfVHJhbnNsdWNlbnRCYWNrZ3JvdW5kKQ0KICAgICAgICANCiAgICAgICAgIyBTdGF0ZQ0KICAgICAgICBzZWxmLnBsYXlsaXN0ID0gW10gDQogICAgICAgIHNlbGYuY3VycmVudF9pbmRleCA9IC0xDQogICAgICAgIHNlbGYubHlyaWNzX2RhdGEgPSBbXSANCiAgICAgICAgc2VsZi5pc19wbGF5aW5nID0gRmFsc2UNCiAgICAgICAgc2VsZi5hY2NlbnRfY29sb3IgPSAiIzFkYjk1NCIgDQogICAgICAgIHNlbGYuYmdfcGl4bWFwID0gTm9uZQ0KICAgICAgICAjIENhY2hlcyBhbmQgbG9ncw0KICAgICAgICBzZWxmLmx5cmljc19jYWNoZSA9IHt9DQogICAgICAgIHNlbGYuY292ZXJfY2FjaGUgPSB7fQ0KICAgICAgICBzZWxmLmxvZ19saW5lcyA9IFtdDQoNCiAgICAgICAgIyBMeXJpY3MgZGlzcGxheSBvcHRpb25zDQogICAgICAgIHNlbGYubHlyaWNzX2ZvbnQgPSBRRm9udCgnQXJpYWwnLCAxMikNCiAgICAgICAgc2VsZi5seXJpY3NfY29sb3IgPSBRQ29sb3IoMjU1LCAyNTUsIDI1NSwgMjAwKQ0KICAgICAgICBzZWxmLnBlcl9jaGFyX3N5bmMgPSBGYWxzZQ0KICAgICAgICANCiAgICAgICAgIyBXaW5kb3cgRHJhZyBTdGF0ZQ0KICAgICAgICBzZWxmLmRyYWdfc3RhcnRfcG9zaXRpb24gPSBRUG9pbnQoKQ0KICAgICAgICBzZWxmLndpbmRvd19zdGFydF9wb3NpdGlvbiA9IFFQb2ludCgpDQogICAgICAgIA0KICAgICAgICAjIE11bHRpbWVkaWEgKFB5UXQ1KQ0KICAgICAgICBzZWxmLnBsYXllciA9IFFNZWRpYVBsYXllcihzZWxmKQ0KICAgICAgICANCiAgICAgICAgc2VsZi5pbml0X3VpKCkNCiAgICAgICAgc2VsZi5zZXR1cF9jb25uZWN0aW9ucygpDQogICAgICAgIA0KICAgICAgICAjIFNldCBWaWRlbyBPdXRwdXQgT05DRSAodG8gYXZvaWQgY3Jhc2hlcyB3aGVuIHN3aXRjaGluZykNCiAgICAgICAgc2VsZi5wbGF5ZXIuc2V0VmlkZW9PdXRwdXQoc2VsZi52aWRlb193aWRnZXQpDQogICAgICAgIA0KICAgICAgICBzZWxmLmN1cnJlbnRfcGxheWxpc3RfaWQgPSBERUZBVUxUX1BMQVlMSVNUX0lEDQogICAgICAgIHNlbGYubG9hZF9vbmxpbmVfcGxheWxpc3QoKQ0KDQogICAgZGVmIHNob3dfd2FybmluZyhzZWxmLCB0aXRsZSwgbWVzc2FnZSk6DQogICAgICAgICMgbG9nIGFuZCBzaG93IGEgUU1lc3NhZ2VCb3gNCiAgICAgICAgZW50cnkgPSBmInt0aXRsZX06IHttZXNzYWdlfSINCiAgICAgICAgc2VsZi5sb2dfbGluZXMuYXBwZW5kKGVudHJ5KQ0KICAgICAgICBRTWVzc2FnZUJveC53YXJuaW5nKHNlbGYsIHRpdGxlLCBtZXNzYWdlKQ0KDQogICAgZGVmIGhhbmRsZV93b3JrZXJfZXJyb3Ioc2VsZiwgbXNnKToNCiAgICAgICAgc2VsZi5zaG93X3dhcm5pbmcoIuivt+axgumUmeivryIsIG1zZykNCg0KICAgIGRlZiB3aW5kb3dfc3RhcnRfbW92ZShzZWxmLCBnbG9iYWxfcG9zKToNCiAgICAgICAgc2VsZi5kcmFnX3N0YXJ0X3Bvc2l0aW9uID0gZ2xvYmFsX3Bvcw0KICAgICAgICBzZWxmLndpbmRvd19zdGFydF9wb3NpdGlvbiA9IHNlbGYucG9zKCkNCg0KICAgIGRlZiB3aW5kb3dfZG9fbW92ZShzZWxmLCBnbG9iYWxfcG9zKToNCiAgICAgICAgZGVsdGEgPSBnbG9iYWxfcG9zIC0gc2VsZi5kcmFnX3N0YXJ0X3Bvc2l0aW9uDQogICAgICAgIHNlbGYubW92ZShzZWxmLndpbmRvd19zdGFydF9wb3NpdGlvbiArIGRlbHRhKQ0KDQogICAgZGVmIGluaXRfdWkoc2VsZik6DQogICAgICAgICMgTWFpbiBDb250YWluZXIgKFJvdW5kZWQgQ29ybmVycyAmIEJhY2tncm91bmQpDQogICAgICAgIHNlbGYuY29udGFpbmVyID0gUVdpZGdldCgpDQogICAgICAgIHNlbGYuY29udGFpbmVyLnNldE9iamVjdE5hbWUoIk1haW5Db250YWluZXIiKQ0KICAgICAgICBzZWxmLnNldENlbnRyYWxXaWRnZXQoc2VsZi5jb250YWluZXIpDQogICAgICAgIA0KICAgICAgICAjIEJhY2tncm91bmQgTGF5ZXIgZm9yIEJsdXINCiAgICAgICAgc2VsZi5iZ19sYWJlbCA9IFFMYWJlbChzZWxmLmNvbnRhaW5lcikNCiAgICAgICAgc2VsZi5iZ19sYWJlbC5zZXRTY2FsZWRDb250ZW50cyhUcnVlKQ0KICAgICAgICBzZWxmLmJnX2xhYmVsLnNldFN0eWxlU2hlZXQoImJhY2tncm91bmQtY29sb3I6ICMyMjI7IikNCiAgICAgICAgDQogICAgICAgICMgQmx1ciBFZmZlY3QNCiAgICAgICAgc2VsZi5ibHVyX2VmZmVjdCA9IFFHcmFwaGljc0JsdXJFZmZlY3QoKQ0KICAgICAgICBzZWxmLmJsdXJfZWZmZWN0LnNldEJsdXJSYWRpdXMoMzApDQogICAgICAgIHNlbGYuYmdfbGFiZWwuc2V0R3JhcGhpY3NFZmZlY3Qoc2VsZi5ibHVyX2VmZmVjdCkNCiAgICAgICAgDQogICAgICAgICMgT3ZlcmxheSBmb3IgdGludA0KICAgICAgICBzZWxmLm92ZXJsYXkgPSBRV2lkZ2V0KHNlbGYuY29udGFpbmVyKQ0KICAgICAgICBzZWxmLm92ZXJsYXkuc2V0U3R5bGVTaGVldCgiYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjYpOyIpDQogICAgICAgIA0KICAgICAgICAjIExheW91dHMNCiAgICAgICAgc2VsZi5tYWluX2xheW91dCA9IFFWQm94TGF5b3V0KHNlbGYuY29udGFpbmVyKQ0KICAgICAgICBzZWxmLm1haW5fbGF5b3V0LnNldENvbnRlbnRzTWFyZ2lucygwLDAsMCwwKQ0KICAgICAgICBzZWxmLm1haW5fbGF5b3V0LnNldFNwYWNpbmcoMCkNCiAgICAgICAgDQogICAgICAgICMgMS4gQ3VzdG9tIFRpdGxlIEJhcg0KICAgICAgICBzZWxmLnRpdGxlX2JhciA9IFRpdGxlQmFyKHNlbGYpDQogICAgICAgIHNlbGYubWFpbl9sYXlvdXQuYWRkV2lkZ2V0KHNlbGYudGl0bGVfYmFyKQ0KICAgICAgICANCiAgICAgICAgIyAyLiBDb250ZW50IEFyZWENCiAgICAgICAgY29udGVudF93aWRnZXQgPSBRV2lkZ2V0KCkNCiAgICAgICAgY29udGVudF9sYXlvdXQgPSBRSEJveExheW91dChjb250ZW50X3dpZGdldCkNCiAgICAgICAgY29udGVudF9sYXlvdXQuc2V0Q29udGVudHNNYXJnaW5zKDIwLCAxMCwgMjAsIDEwKQ0KICAgICAgICANCiAgICAgICAgIyBMZWZ0OiBQbGF5bGlzdA0KICAgICAgICBzZWxmLnBsYXlsaXN0X3dpZGdldCA9IFFMaXN0V2lkZ2V0KCkNCiAgICAgICAgc2VsZi5wbGF5bGlzdF93aWRnZXQuc2V0Rml4ZWRXaWR0aCgyNjApDQogICAgICAgIHNlbGYucGxheWxpc3Rfd2lkZ2V0LnNldEZyYW1lU2hhcGUoUUZyYW1lLk5vRnJhbWUpDQogICAgICAgIHNlbGYucGxheWxpc3Rfd2lkZ2V0Lml0ZW1Eb3VibGVDbGlja2VkLmNvbm5lY3Qoc2VsZi5vbl9wbGF5bGlzdF9kb3VibGVfY2xpY2spDQogICAgICAgIA0KICAgICAgICAjIFJpZ2h0OiBEaXNwbGF5DQogICAgICAgIHNlbGYuY29udGVudF9zdGFjayA9IFFTdGFja2VkV2lkZ2V0KCkNCiAgICAgICAgDQogICAgICAgICMgQXVkaW8gUGFnZQ0KICAgICAgICBhdWRpb19wYWdlID0gUVdpZGdldCgpDQogICAgICAgIGF1ZGlvX2xheW91dCA9IFFWQm94TGF5b3V0KGF1ZGlvX3BhZ2UpDQogICAgICAgIA0KICAgICAgICBzZWxmLmxibF90aXRsZSA9IFFMYWJlbCgiUmVhZHkgdG8gUGxheSIpDQogICAgICAgIHNlbGYubGJsX3RpdGxlLnNldEFsaWdubWVudChRdC5BbGlnbkNlbnRlcikNCiAgICAgICAgc2VsZi5sYmxfdGl0bGUuc2V0V29yZFdyYXAoVHJ1ZSkNCiAgICAgICAgc2VsZi5sYmxfdGl0bGUuc2V0U3R5bGVTaGVldCgiZm9udC1zaXplOiAyNHB4OyBmb250LXdlaWdodDogYm9sZDsgY29sb3I6IHdoaXRlOyBtYXJnaW4tYm90dG9tOiA1cHg7IikNCiAgICAgICAgDQogICAgICAgIHNlbGYubGJsX2FydGlzdCA9IFFMYWJlbCgiIikNCiAgICAgICAgc2VsZi5sYmxfYXJ0aXN0LnNldEFsaWdubWVudChRdC5BbGlnbkNlbnRlcikNCiAgICAgICAgc2VsZi5sYmxfYXJ0aXN0LnNldFN0eWxlU2hlZXQoImZvbnQtc2l6ZTogMTZweDsgY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC43KTsgbWFyZ2luLWJvdHRvbTogMjBweDsiKQ0KICAgICAgICANCiAgICAgICAgc2VsZi5seXJpY3NfbGlzdCA9IFFMaXN0V2lkZ2V0KCkNCiAgICAgICAgc2VsZi5seXJpY3NfbGlzdC5zZXRGb2N1c1BvbGljeShRdC5Ob0ZvY3VzKQ0KICAgICAgICBzZWxmLmx5cmljc19saXN0LnNldFZlcnRpY2FsU2Nyb2xsQmFyUG9saWN5KFF0LlNjcm9sbEJhckFsd2F5c09mZikNCiAgICAgICAgc2VsZi5seXJpY3NfbGlzdC5zZXRGcmFtZVNoYXBlKFFGcmFtZS5Ob0ZyYW1lKQ0KICAgICAgICBzZWxmLmx5cmljc19saXN0LnNldFN0eWxlU2hlZXQoImJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyIpDQogICAgICAgIA0KICAgICAgICBhdWRpb19sYXlvdXQuYWRkU3RyZXRjaCgpDQogICAgICAgIGF1ZGlvX2xheW91dC5hZGRXaWRnZXQoc2VsZi5sYmxfdGl0bGUpDQogICAgICAgIGF1ZGlvX2xheW91dC5hZGRXaWRnZXQoc2VsZi5sYmxfYXJ0aXN0KQ0KICAgICAgICBhdWRpb19sYXlvdXQuYWRkV2lkZ2V0KHNlbGYubHlyaWNzX2xpc3QpDQogICAgICAgIGF1ZGlvX2xheW91dC5hZGRTdHJldGNoKCkNCiAgICAgICAgDQogICAgICAgICMgVmlkZW8gUGFnZQ0KICAgICAgICBzZWxmLnZpZGVvX3dpZGdldCA9IFFWaWRlb1dpZGdldCgpDQogICAgICAgIA0KICAgICAgICBzZWxmLmNvbnRlbnRfc3RhY2suYWRkV2lkZ2V0KGF1ZGlvX3BhZ2UpDQogICAgICAgIHNlbGYuY29udGVudF9zdGFjay5hZGRXaWRnZXQoc2VsZi52aWRlb193aWRnZXQpDQogICAgICAgIA0KICAgICAgICBjb250ZW50X2xheW91dC5hZGRXaWRnZXQoc2VsZi5wbGF5bGlzdF93aWRnZXQpDQogICAgICAgIGNvbnRlbnRfbGF5b3V0LmFkZFdpZGdldChzZWxmLmNvbnRlbnRfc3RhY2spDQogICAgICAgIA0KICAgICAgICBzZWxmLm1haW5fbGF5b3V0LmFkZFdpZGdldChjb250ZW50X3dpZGdldCkNCiAgICAgICAgDQogICAgICAgICMgMy4gQ29udHJvbHMNCiAgICAgICAgY29udHJvbHNfYmFyID0gUVdpZGdldCgpDQogICAgICAgIGNvbnRyb2xzX2Jhci5zZXRGaXhlZEhlaWdodCg5MCkNCiAgICAgICAgY29udHJvbHNfYmFyLnNldFN0eWxlU2hlZXQoImJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMC4zKTsgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKTsiKQ0KICAgICAgICBjX2xheW91dCA9IFFIQm94TGF5b3V0KGNvbnRyb2xzX2JhcikNCiAgICAgICAgY19sYXlvdXQuc2V0Q29udGVudHNNYXJnaW5zKDIwLCAxMCwgMjAsIDEwKQ0KICAgICAgICANCiAgICAgICAgc2VsZi5idG5fcHJldiA9IFFQdXNoQnV0dG9uKCLij64iKQ0KICAgICAgICBzZWxmLmJ0bl9wbGF5ID0gUVB1c2hCdXR0b24oIuKWtiIpDQogICAgICAgIHNlbGYuYnRuX25leHQgPSBRUHVzaEJ1dHRvbigi4o+tIikNCiAgICAgICAgc2VsZi5idG5fb3BlbiA9IFFQdXNoQnV0dG9uKCLwn5OBIikNCiAgICAgICAgDQogICAgICAgIGZvciBidG4gaW4gW3NlbGYuYnRuX3ByZXYsIHNlbGYuYnRuX25leHRdOg0KICAgICAgICAgICAgYnRuLnNldEZpeGVkU2l6ZSg0MCwgNDApDQogICAgICAgICAgICBidG4uc2V0T2JqZWN0TmFtZSgiQ3RybEJ0biIpDQogICAgICAgICAgICANCiAgICAgICAgc2VsZi5idG5fcGxheS5zZXRGaXhlZFNpemUoNTAsIDUwKQ0KICAgICAgICBzZWxmLmJ0bl9wbGF5LnNldE9iamVjdE5hbWUoIlBsYXlCdG4iKQ0KICAgICAgICANCiAgICAgICAgc2VsZi5idG5fcHJldi5jbGlja2VkLmNvbm5lY3Qoc2VsZi5wbGF5X3ByZXYpDQogICAgICAgIHNlbGYuYnRuX3BsYXkuY2xpY2tlZC5jb25uZWN0KHNlbGYudG9nZ2xlX3BsYXkpDQogICAgICAgIHNlbGYuYnRuX25leHQuY2xpY2tlZC5jb25uZWN0KHNlbGYucGxheV9uZXh0KQ0KICAgICAgICBzZWxmLmJ0bl9vcGVuLmNsaWNrZWQuY29ubmVjdChzZWxmLm9wZW5fbG9jYWxfZmlsZXMpDQogICAgICAgIA0KICAgICAgICAjIFByb2dyZXNzDQogICAgICAgIHNlbGYubGJsX2N1cnIgPSBRTGFiZWwoIjAwOjAwIikNCiAgICAgICAgc2VsZi5zbGlkZXIgPSBRU2xpZGVyKFF0Lkhvcml6b250YWwpDQogICAgICAgIHNlbGYuc2xpZGVyLnNsaWRlck1vdmVkLmNvbm5lY3Qoc2VsZi5zZXRfcG9zaXRpb24pDQogICAgICAgIHNlbGYubGJsX3RvdGFsID0gUUxhYmVsKCIwMDowMCIpDQogICAgICAgIA0KICAgICAgICBmb3IgbCBpbiBbc2VsZi5sYmxfY3Vyciwgc2VsZi5sYmxfdG90YWxdOg0KICAgICAgICAgICAgbC5zZXRTdHlsZVNoZWV0KCJjb2xvcjogI2NjYzsgZm9udC1zaXplOiAxMnB4OyIpDQogICAgICAgICAgICANCiAgICAgICAgIyBWb2x1bWUNCiAgICAgICAgc2VsZi5idG5fdm9sID0gUVB1c2hCdXR0b24oIvCflIoiKQ0KICAgICAgICBzZWxmLmJ0bl92b2wuc2V0RmxhdChUcnVlKQ0KICAgICAgICBzZWxmLmJ0bl92b2wuc2V0U3R5bGVTaGVldCgiY29sb3I6ICNjY2M7IGJvcmRlcjogbm9uZTsiKQ0KICAgICAgICBzZWxmLnNsaWRlcl92b2wgPSBRU2xpZGVyKFF0Lkhvcml6b250YWwpDQogICAgICAgIHNlbGYuc2xpZGVyX3ZvbC5zZXRGaXhlZFdpZHRoKDgwKQ0KICAgICAgICBzZWxmLnNsaWRlcl92b2wuc2V0UmFuZ2UoMCwgMTAwKQ0KICAgICAgICBzZWxmLnNsaWRlcl92b2wuc2V0VmFsdWUoNzApDQogICAgICAgIHNlbGYuc2xpZGVyX3ZvbC52YWx1ZUNoYW5nZWQuY29ubmVjdChzZWxmLnBsYXllci5zZXRWb2x1bWUpDQogICAgICAgIA0KICAgICAgICBjX2xheW91dC5hZGRXaWRnZXQoc2VsZi5idG5fcHJldikNCiAgICAgICAgY19sYXlvdXQuYWRkU3BhY2luZygxMCkNCiAgICAgICAgY19sYXlvdXQuYWRkV2lkZ2V0KHNlbGYuYnRuX29wZW4pDQogICAgICAgIGNfbGF5b3V0LmFkZFNwYWNpbmcoMTApDQogICAgICAgIGNfbGF5b3V0LmFkZFdpZGdldChzZWxmLmJ0bl9wbGF5KQ0KICAgICAgICBjX2xheW91dC5hZGRTcGFjaW5nKDEwKQ0KICAgICAgICBjX2xheW91dC5hZGRXaWRnZXQoc2VsZi5idG5fbmV4dCkNCiAgICAgICAgY19sYXlvdXQuYWRkU3BhY2luZygyMCkNCiAgICAgICAgY19sYXlvdXQuYWRkV2lkZ2V0KHNlbGYubGJsX2N1cnIpDQogICAgICAgIGNfbGF5b3V0LmFkZFdpZGdldChzZWxmLnNsaWRlcikNCiAgICAgICAgY19sYXlvdXQuYWRkV2lkZ2V0KHNlbGYubGJsX3RvdGFsKQ0KICAgICAgICBjX2xheW91dC5hZGRTcGFjaW5nKDIwKQ0KICAgICAgICBjX2xheW91dC5hZGRXaWRnZXQoc2VsZi5idG5fdm9sKQ0KICAgICAgICBjX2xheW91dC5hZGRXaWRnZXQoc2VsZi5zbGlkZXJfdm9sKQ0KICAgICAgICBjX2xheW91dC5hZGRTdHJldGNoKCkNCiAgICAgICAgc2VsZi5sYmxfdmVyc2lvbiA9IFFMYWJlbCgidjAuMi4xIMKpWmhpTWEgMjAyNiIpDQogICAgICAgIHNlbGYubGJsX3ZlcnNpb24uc2V0U3R5bGVTaGVldCgiY29sb3I6ICNhYWE7IikNCiAgICAgICAgY19sYXlvdXQuYWRkV2lkZ2V0KHNlbGYubGJsX3ZlcnNpb24pDQogICAgICAgIA0KICAgICAgICBzZWxmLm1haW5fbGF5b3V0LmFkZFdpZGdldChjb250cm9sc19iYXIpDQogICAgICAgIA0KICAgICAgICBzZWxmLmFwcGx5X3FzcygpDQoNCiAgICBkZWYgcmVzaXplRXZlbnQoc2VsZiwgZXZlbnQpOg0KICAgICAgICBzZWxmLmJnX2xhYmVsLnJlc2l6ZShzZWxmLnNpemUoKSkNCiAgICAgICAgc2VsZi5vdmVybGF5LnJlc2l6ZShzZWxmLnNpemUoKSkNCiAgICAgICAgc3VwZXIoKS5yZXNpemVFdmVudChldmVudCkNCg0KICAgIGRlZiBhcHBseV9xc3Moc2VsZik6DQogICAgICAgIHFzcyA9IGYiIiINCiAgICAgICAgICAgICNNYWluQ29udGFpbmVyIHt7DQogICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7DQogICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTVweDsNCiAgICAgICAgICAgIH19DQogICAgICAgICAgICBRTGlzdFdpZGdldCB7ew0KICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4yKTsNCiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4Ow0KICAgICAgICAgICAgICAgIGNvbG9yOiAjZGRkOw0KICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsNCiAgICAgICAgICAgICAgICBwYWRkaW5nOiA1cHg7DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgUUxpc3RXaWRnZXQ6Oml0ZW0ge3sNCiAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwcHg7DQogICAgICAgICAgICAgICAgcGFkZGluZzogNXB4Ow0KICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDsNCiAgICAgICAgICAgIH19DQogICAgICAgICAgICBRTGlzdFdpZGdldDo6aXRlbTpzZWxlY3RlZCB7ew0KICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC4xNSk7DQogICAgICAgICAgICAgICAgY29sb3I6IHtzZWxmLmFjY2VudF9jb2xvcn07DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgUUxpc3RXaWRnZXQ6Oml0ZW06aG92ZXIge3sNCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LDAuMDUpOw0KICAgICAgICAgICAgfX0NCiAgICAgICAgICAgIA0KICAgICAgICAgICAgLyogQ29udHJvbHMgKi8NCiAgICAgICAgICAgICNDdHJsQnRuIHt7DQogICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7DQogICAgICAgICAgICAgICAgY29sb3I6IHdoaXRlOw0KICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKTsNCiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4Ow0KICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsNCiAgICAgICAgICAgIH19DQogICAgICAgICAgICAjQ3RybEJ0bjpob3ZlciB7ew0KICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC4xKTsNCiAgICAgICAgICAgICAgICBib3JkZXItY29sb3I6IHdoaXRlOw0KICAgICAgICAgICAgfX0NCiAgICAgICAgICAgICNQbGF5QnRuIHt7DQogICAgICAgICAgICAgICAgYmFja2dyb3VuZDoge3NlbGYuYWNjZW50X2NvbG9yfTsNCiAgICAgICAgICAgICAgICBjb2xvcjogd2hpdGU7DQogICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjVweDsNCiAgICAgICAgICAgICAgICBmb250LXNpemU6IDIwcHg7DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgI1BsYXlCdG46aG92ZXIge3sNCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMWVkNzYwOw0KICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNSk7DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgDQogICAgICAgICAgICAvKiBTbGlkZXJzICovDQogICAgICAgICAgICBRU2xpZGVyOjpncm9vdmU6aG9yaXpvbnRhbCB7ew0KICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKTsNCiAgICAgICAgICAgICAgICBoZWlnaHQ6IDRweDsNCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuMik7DQogICAgICAgICAgICAgICAgbWFyZ2luOiAycHggMDsNCiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgUVNsaWRlcjo6aGFuZGxlOmhvcml6b250YWwge3sNCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsNCiAgICAgICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjNWM1YzVjOw0KICAgICAgICAgICAgICAgIHdpZHRoOiAxNHB4Ow0KICAgICAgICAgICAgICAgIGhlaWdodDogMTRweDsNCiAgICAgICAgICAgICAgICBtYXJnaW46IC02cHggMDsNCiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA3cHg7DQogICAgICAgICAgICB9fQ0KICAgICAgICAgICAgUVNsaWRlcjo6c3ViLXBhZ2U6aG9yaXpvbnRhbCB7ew0KICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHtzZWxmLmFjY2VudF9jb2xvcn07DQogICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4Ow0KICAgICAgICAgICAgfX0NCiAgICAgICAgIiIiDQogICAgICAgIHNlbGYuc2V0U3R5bGVTaGVldChxc3MpDQoNCiAgICBkZWYgc2V0dXBfY29ubmVjdGlvbnMoc2VsZik6DQogICAgICAgIHNlbGYucGxheWVyLnBvc2l0aW9uQ2hhbmdlZC5jb25uZWN0KHNlbGYub25fcG9zaXRpb25fY2hhbmdlZCkNCiAgICAgICAgc2VsZi5wbGF5ZXIuZHVyYXRpb25DaGFuZ2VkLmNvbm5lY3Qoc2VsZi5vbl9kdXJhdGlvbl9jaGFuZ2VkKQ0KICAgICAgICBzZWxmLnBsYXllci5tZWRpYVN0YXR1c0NoYW5nZWQuY29ubmVjdChzZWxmLm9uX21lZGlhX3N0YXR1c19jaGFuZ2VkKQ0KICAgICAgICBzZWxmLnBsYXllci5lcnJvci5jb25uZWN0KHNlbGYub25fcGxheWVyX2Vycm9yKQ0KDQogICAgIyAtLS0gTG9naWMgLS0tDQoNCiAgICBkZWYgbG9hZF9vbmxpbmVfcGxheWxpc3Qoc2VsZik6DQogICAgICAgICMgc3RvcCBwcmV2aW91cyB3b3JrZXIgaWYgcnVubmluZw0KICAgICAgICBpZiBoYXNhdHRyKHNlbGYsICd3b3JrZXInKSBhbmQgc2VsZi53b3JrZXIuaXNSdW5uaW5nKCk6DQogICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgc2VsZi53b3JrZXIucXVpdCgpDQogICAgICAgICAgICAgICAgc2VsZi53b3JrZXIud2FpdCgpDQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICAgICAgICAgIHBhc3MNCg0KICAgICAgICB1cmwgPSBmIntBUElfQkFTRX0/c2VydmVyPW5ldGVhc2UmdHlwZT1wbGF5bGlzdCZpZD17c2VsZi5jdXJyZW50X3BsYXlsaXN0X2lkfSINCiAgICAgICAgc2VsZi50aXRsZV9iYXIudGl0bGVfbGFiZWwuc2V0VGV4dCgiTG9hZGluZy4uLiIpDQogICAgICAgIHNlbGYud29ya2VyID0gQXBpV29ya2VyKHVybCwgc2VydmVyPSJuZXRlYXNlIiwgcGxheWxpc3RfaWQ9c2VsZi5jdXJyZW50X3BsYXlsaXN0X2lkLCBwYXJlbnQ9c2VsZikNCiAgICAgICAgc2VsZi53b3JrZXIuZmluaXNoZWQuY29ubmVjdChzZWxmLm9uX3BsYXlsaXN0X2xvYWRlZCkNCiAgICAgICAgc2VsZi53b3JrZXIuZXJyb3IuY29ubmVjdChzZWxmLmhhbmRsZV93b3JrZXJfZXJyb3IpDQogICAgICAgIHNlbGYud29ya2VyLnN0YXJ0KCkNCg0KICAgIGRlZiBvbl9wbGF5bGlzdF9sb2FkZWQoc2VsZiwgZGF0YSwgcGxheWxpc3RfbmFtZSk6DQogICAgICAgIHNlbGYucGxheWxpc3QgPSBkYXRhDQogICAgICAgIHNlbGYucGxheWxpc3Rfd2lkZ2V0LmNsZWFyKCkNCiAgICAgICAgZm9yIHRyYWNrIGluIHNlbGYucGxheWxpc3Q6DQogICAgICAgICAgICBuYW1lID0gdHJhY2suZ2V0KCduYW1lJywgJ1Vua25vd24nKQ0KICAgICAgICAgICAgYXJ0aXN0ID0gdHJhY2suZ2V0KCdhcnRpc3QnLCAnVW5rbm93bicpDQogICAgICAgICAgICBzZWxmLnBsYXlsaXN0X3dpZGdldC5hZGRJdGVtKGYie25hbWV9IC0ge2FydGlzdH0iKQ0KICAgICAgICBzZWxmLnRpdGxlX2Jhci50aXRsZV9sYWJlbC5zZXRUZXh0KGYie3BsYXlsaXN0X25hbWV9IikNCiAgICAgICAgIyBsb2cgcGxheWxpc3QgbG9hZA0KICAgICAgICB0cnk6DQogICAgICAgICAgICBzZWxmLmxvZ19saW5lcy5hcHBlbmQoZiJMb2FkZWQgcGxheWxpc3Q6IHtwbGF5bGlzdF9uYW1lfSAoe2xlbihzZWxmLnBsYXlsaXN0KX0gdHJhY2tzKSIpDQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgICAgICBwYXNzDQogICAgICAgICMgaWYgbm8gdHJhY2sgd2FzIHBsYXlpbmcgYmVmb3JlLCBzdGFydCBwbGF5aW5nIGZpcnN0IHRyYWNrOyBvdGhlcndpc2Uga2VlcCBjdXJyZW50IHBsYXliYWNrDQogICAgICAgIGlmIGdldGF0dHIoc2VsZiwgJ2N1cnJlbnRfaW5kZXgnLCAtMSkgPT0gLTEgYW5kIHNlbGYucGxheWxpc3Q6DQogICAgICAgICAgICBzZWxmLnBsYXlfdHJhY2soMCkNCg0KICAgIGRlZiBvbl9wbGF5bGlzdF9kb3VibGVfY2xpY2soc2VsZiwgaXRlbSk6DQogICAgICAgIGlkeCA9IHNlbGYucGxheWxpc3Rfd2lkZ2V0LnJvdyhpdGVtKQ0KICAgICAgICBzZWxmLnBsYXlfdHJhY2soaWR4KQ0KDQogICAgZGVmIG9wZW5fc2V0dGluZ3Moc2VsZik6DQogICAgICAgIGRsZyA9IFNldHRpbmdzRGlhbG9nKHNlbGYpDQogICAgICAgIGlmIGRsZy5leGVjXygpOg0KICAgICAgICAgICAgbmV3X2lkID0gZGxnLmxlX3BsYXlsaXN0LnRleHQoKS5zdHJpcCgpDQogICAgICAgICAgICBpZiBuZXdfaWQgPT0gIiI6DQogICAgICAgICAgICAgICAgbmV3X2lkID0gREVGQVVMVF9QTEFZTElTVF9JRA0KDQogICAgICAgICAgICAjIGFwcGx5IGx5cmljcyBkaXNwbGF5IHNldHRpbmdzIGltbWVkaWF0ZWx5DQogICAgICAgICAgICBzZWxmLnBlcl9jaGFyX3N5bmMgPSBkbGcuY2JfcGVyY2hhci5pc0NoZWNrZWQoKQ0KICAgICAgICAgICAgc2VsZi5seXJpY3NfZm9udCA9IGdldGF0dHIoc2VsZiwgJ2x5cmljc19mb250JywgUUZvbnQoJ0FyaWFsJywgMTIpKQ0KICAgICAgICAgICAgc2VsZi5seXJpY3NfY29sb3IgPSBnZXRhdHRyKHNlbGYsICdseXJpY3NfY29sb3InLCBRQ29sb3IoMjU1LDI1NSwyNTUsMjAwKSkNCg0KICAgICAgICAgICAgIyBPbmx5IHJlbG9hZCBwbGF5bGlzdCBpZiBJRCBhY3R1YWxseSBjaGFuZ2VkDQogICAgICAgICAgICBpZiBzdHIobmV3X2lkKSAhPSBzdHIoZ2V0YXR0cihzZWxmLCAnY3VycmVudF9wbGF5bGlzdF9pZCcsIERFRkFVTFRfUExBWUxJU1RfSUQpKToNCiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRfcGxheWxpc3RfaWQgPSBuZXdfaWQNCiAgICAgICAgICAgICAgICBzZWxmLmxvZ19saW5lcy5hcHBlbmQoZiJQbGF5bGlzdCBJRCBjaGFuZ2VkIC0+IHJlbG9hZGluZzoge3NlbGYuY3VycmVudF9wbGF5bGlzdF9pZH0iKQ0KICAgICAgICAgICAgICAgIHNlbGYubG9hZF9vbmxpbmVfcGxheWxpc3QoKQ0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAjIHVwZGF0ZSBseXJpY3MgVUkgKG5vIGludGVycnVwdGlvbikNCiAgICAgICAgICAgICAgICBmb3IgaSBpbiByYW5nZShzZWxmLmx5cmljc19saXN0LmNvdW50KCkpOg0KICAgICAgICAgICAgICAgICAgICBpdCA9IHNlbGYubHlyaWNzX2xpc3QuaXRlbShpKQ0KICAgICAgICAgICAgICAgICAgICBpdC5zZXRGb250KHNlbGYubHlyaWNzX2ZvbnQpDQogICAgICAgICAgICAgICAgICAgIGl0LnNldEZvcmVncm91bmQoc2VsZi5seXJpY3NfY29sb3IpDQogICAgICAgICAgICAgICAgc2VsZi5sb2dfbGluZXMuYXBwZW5kKCJTZXR0aW5ncyBhcHBsaWVkIChubyByZWxvYWQpIikNCg0KICAgIGRlZiBvcGVuX2xvY2FsX2ZpbGVzKHNlbGYpOg0KICAgICAgICBmaWxlcywgXyA9IFFGaWxlRGlhbG9nLmdldE9wZW5GaWxlTmFtZXMoc2VsZiwgIumAieaLqemfs+mikeaIluinhumikeaWh+S7tiIsIG9zLnBhdGguZXhwYW5kdXNlcignficpLCAi6Z+z6aKRL+inhumikSAoKi5tcDMgKi53YXYgKi5mbGFjICoubXA0ICoubWt2ICouYXZpICoud2VibSk7O0FsbCBGaWxlcyAoKikiKQ0KICAgICAgICBpZiBub3QgZmlsZXM6DQogICAgICAgICAgICByZXR1cm4NCiAgICAgICAgaW5zZXJ0X2F0ID0gc2VsZi5jdXJyZW50X2luZGV4ICsgMSBpZiBzZWxmLmN1cnJlbnRfaW5kZXggPj0gMCBlbHNlIGxlbihzZWxmLnBsYXlsaXN0KQ0KICAgICAgICBmb3IgaSwgcCBpbiBlbnVtZXJhdGUoZmlsZXMpOg0KICAgICAgICAgICAgaXRlbSA9IHsnbmFtZSc6IG9zLnBhdGguYmFzZW5hbWUocCksICdhcnRpc3QnOiAn5pys5Zyw5paH5Lu2JywgJ3BhdGgnOiBwLCAnaXNfbG9jYWwnOiBUcnVlfQ0KICAgICAgICAgICAgc2VsZi5wbGF5bGlzdC5pbnNlcnQoaW5zZXJ0X2F0ICsgaSwgaXRlbSkNCiAgICAgICAgICAgIHNlbGYucGxheWxpc3Rfd2lkZ2V0Lmluc2VydEl0ZW0oaW5zZXJ0X2F0ICsgaSwgZiJ7aXRlbVsnbmFtZSddfSAtIHtpdGVtWydhcnRpc3QnXX0iKQ0KICAgICAgICAjIHBsYXkgZmlyc3Qgc2VsZWN0ZWQNCiAgICAgICAgc2VsZi5wbGF5X3RyYWNrKGluc2VydF9hdCkNCg0KICAgIGRlZiBwbGF5X3RyYWNrKHNlbGYsIGluZGV4KToNCiAgICAgICAgaWYgbm90IHNlbGYucGxheWxpc3Qgb3IgaW5kZXggPCAwIG9yIGluZGV4ID49IGxlbihzZWxmLnBsYXlsaXN0KToNCiAgICAgICAgICAgIHJldHVybg0KDQogICAgICAgIHNlbGYuY3VycmVudF9pbmRleCA9IGluZGV4DQogICAgICAgIHRyYWNrID0gc2VsZi5wbGF5bGlzdFtpbmRleF0NCiAgICAgICAgc2VsZi5wbGF5bGlzdF93aWRnZXQuc2V0Q3VycmVudFJvdyhpbmRleCkNCiAgICAgICAgDQogICAgICAgICMgSW5mbw0KICAgICAgICBuYW1lID0gdHJhY2suZ2V0KCduYW1lJywgJ1Vua25vd24nKQ0KICAgICAgICBhcnRpc3QgPSB0cmFjay5nZXQoJ2FydGlzdCcsICdVbmtub3duJykNCiAgICAgICAgc2VsZi5sYmxfdGl0bGUuc2V0VGV4dChuYW1lKQ0KICAgICAgICBzZWxmLmxibF9hcnRpc3Quc2V0VGV4dChhcnRpc3QpDQogICAgICAgIHRyeToNCiAgICAgICAgICAgIHNlbGYubG9nX2xpbmVzLmFwcGVuZChmIlBsYXk6IHtuYW1lfSAtIHthcnRpc3R9IChpbmRleD17c2VsZi5jdXJyZW50X2luZGV4fSkiKQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICAgICAgcGFzcw0KICAgICAgICANCiAgICAgICAgIyBCYWNrZ3JvdW5kIEltYWdlDQogICAgICAgIHBpY191cmwgPSB0cmFjay5nZXQoJ3BpYycsICcnKQ0KICAgICAgICBpZiBwaWNfdXJsOg0KICAgICAgICAgICAgIyB1c2UgY2FjaGUgd2hlbiBwb3NzaWJsZQ0KICAgICAgICAgICAgaWYgcGljX3VybCBpbiBzZWxmLmNvdmVyX2NhY2hlOg0KICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhY2tncm91bmQoc2VsZi5jb3Zlcl9jYWNoZVtwaWNfdXJsXSkNCiAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgaWYgaGFzYXR0cihzZWxmLCAnaW1nX3dvcmtlcicpIGFuZCBnZXRhdHRyKHNlbGYsICdpbWdfd29ya2VyJykuaXNSdW5uaW5nKCk6DQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW1nX3dvcmtlci5xdWl0KCk7IHNlbGYuaW1nX3dvcmtlci53YWl0KCkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MNCiAgICAgICAgICAgICAgICBzZWxmLmltZ193b3JrZXIgPSBJbWFnZVdvcmtlcihwaWNfdXJsLCBwYXJlbnQ9c2VsZikNCiAgICAgICAgICAgICAgICBzZWxmLmltZ193b3JrZXIuZmluaXNoZWQuY29ubmVjdChsYW1iZGEgaW1nLCB1cmw9cGljX3VybDogc2VsZi5oYW5kbGVfaW1hZ2VfZmluaXNoZWQoaW1nLCB1cmwpKQ0KICAgICAgICAgICAgICAgIHNlbGYuaW1nX3dvcmtlci5lcnJvci5jb25uZWN0KHNlbGYuaGFuZGxlX3dvcmtlcl9lcnJvcikNCiAgICAgICAgICAgICAgICBzZWxmLmltZ193b3JrZXIuc3RhcnQoKQ0KICAgICAgICANCiAgICAgICAgIyBVUkwNCiAgICAgICAgdXJsID0gdHJhY2suZ2V0KCd1cmwnKQ0KICAgICAgICBpc19sb2NhbCA9IHRyYWNrLmdldCgnaXNfbG9jYWwnLCBGYWxzZSkNCiAgICAgICAgaWYgbm90IHVybCBvciAnbnVsbCcgaW4gdXJsOg0KICAgICAgICAgICAgaWYgdHJhY2suZ2V0KCdpZCcpOg0KICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgYXBpX3VybCA9IGYie0FQSV9CQVNFfT9zZXJ2ZXI9bmV0ZWFzZSZ0eXBlPXVybCZpZD17dHJhY2tbJ2lkJ119Ig0KICAgICAgICAgICAgICAgICAgICByZXNwID0gcmVxdWVzdHMuZ2V0KGFwaV91cmwsIGhlYWRlcnM9UkVRVUVTVF9IRUFERVJTLCB0aW1lb3V0PVJFUVVFU1RfVElNRU9VVCkNCiAgICAgICAgICAgICAgICAgICAgcmVzcC5yYWlzZV9mb3Jfc3RhdHVzKCkNCiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3AuanNvbigpDQogICAgICAgICAgICAgICAgICAgIHVybCA9IGRhdGEuZ2V0KCd1cmwnKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93X3dhcm5pbmcoIuaSreaUvuWksei0pSIsIGYi6I635Y+W5puy55uu5pKt5pS+6ZO+5o6l5aSx6LSlOiB7ZX0iKQ0KICAgICAgICAgICAgICAgICAgICB1cmwgPSBOb25lDQogICAgICAgIA0KICAgICAgICBpZiBpc19sb2NhbDoNCiAgICAgICAgICAgICMgbG9jYWwgZmlsZSBwYXRoIHByb3ZpZGVkIGluICdwYXRoJw0KICAgICAgICAgICAgcGF0aCA9IHRyYWNrLmdldCgncGF0aCcpDQogICAgICAgICAgICBpZiBwYXRoIGFuZCBvcy5wYXRoLmV4aXN0cyhwYXRoKToNCiAgICAgICAgICAgICAgICBxdXJsID0gUVVybC5mcm9tTG9jYWxGaWxlKHBhdGgpDQogICAgICAgICAgICAgICAgbWVkaWEgPSBRTWVkaWFDb250ZW50KHF1cmwpDQogICAgICAgICAgICAgICAgaXNfdmlkZW8gPSBwYXRoLmxvd2VyKCkuZW5kc3dpdGgoKCcubXA0JywgJy5ta3YnLCAnLmF2aScsICcud2VibScpKQ0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICBzZWxmLnNob3dfd2FybmluZygi5pKt5pS+5aSx6LSlIiwgZiLmnKzlnLDmlofku7bkuI3lrZjlnKg6IHt0cmFjay5nZXQoJ25hbWUnKX0iKQ0KICAgICAgICAgICAgICAgIFFUaW1lci5zaW5nbGVTaG90KDEwMCwgc2VsZi5wbGF5X25leHQpDQogICAgICAgICAgICAgICAgcmV0dXJuDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBpZiBub3QgdXJsIG9yICdudWxsJyBpbiB1cmw6DQogICAgICAgICAgICAgICAgc2VsZi5zaG93X3dhcm5pbmcoIuaSreaUvuWksei0pSIsIGYi5puy55uuIHt0cmFjay5nZXQoJ25hbWUnKX0g5pKt5pS+6ZO+5o6l5peg5pWI77yM6Ieq5Yqo5YiH5o2i5LiL5LiA5puyIikNCiAgICAgICAgICAgICAgICBRVGltZXIuc2luZ2xlU2hvdCgxMDAsIHNlbGYucGxheV9uZXh0KQ0KICAgICAgICAgICAgICAgIHJldHVybg0KICAgICAgICAgICAgcXVybCA9IFFVcmwodXJsKQ0KICAgICAgICAgICAgbWVkaWEgPSBRTWVkaWFDb250ZW50KHF1cmwpDQoNCiAgICAgICAgIyBWaWRlbyBDaGVjaw0KICAgICAgICBpc192aWRlbyA9IEZhbHNlDQogICAgICAgIGlmIGlzaW5zdGFuY2UodXJsLCBzdHIpIGFuZCB1cmwubG93ZXIoKS5lbmRzd2l0aCgoJy5tcDQnLCAnLm1rdicsICcuYXZpJywgJy53ZWJtJykpOg0KICAgICAgICAgICAgaXNfdmlkZW8gPSBUcnVlDQogICAgICAgIA0KICAgICAgICBpZiBpc192aWRlbzoNCiAgICAgICAgICAgIHNlbGYuY29udGVudF9zdGFjay5zZXRDdXJyZW50V2lkZ2V0KHNlbGYudmlkZW9fd2lkZ2V0KQ0KICAgICAgICAgICAgIyBzZWxmLnBsYXllci5zZXRWaWRlb091dHB1dChzZWxmLnZpZGVvX3dpZGdldCkgIyBBbHJlYWR5IHNldA0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgc2VsZi5jb250ZW50X3N0YWNrLnNldEN1cnJlbnRXaWRnZXQoc2VsZi5jb250ZW50X3N0YWNrLndpZGdldCgwKSkNCiAgICAgICAgICAgICMgc2VsZi5wbGF5ZXIuc2V0VmlkZW9PdXRwdXQoTm9uZSkgIyBBdm9pZCBjcmFzaGluZyBieSBOT1QgdW5zZXR0aW5nDQogICAgICAgICAgICANCiAgICAgICAgc2VsZi5wbGF5ZXIuc2V0TWVkaWEobWVkaWEpDQogICAgICAgIHNlbGYucGxheWVyLnBsYXkoKQ0KICAgICAgICBzZWxmLmlzX3BsYXlpbmcgPSBUcnVlDQogICAgICAgIHNlbGYuYnRuX3BsYXkuc2V0VGV4dCgi4o+4IikNCiAgICAgICAgDQogICAgICAgICMgTHlyaWNzDQogICAgICAgIGlmIG5vdCBpc192aWRlbzoNCiAgICAgICAgICAgIHNlbGYubHlyaWNzX2xpc3QuY2xlYXIoKQ0KICAgICAgICAgICAgc2VsZi5seXJpY3NfZGF0YSA9IFtdDQogICAgICAgICAgICAjIHRyeSBjYWNoZSBmaXJzdA0KICAgICAgICAgICAgbHlyaWNfa2V5ID0gc3RyKHRyYWNrLmdldCgnaWQnKSBvciB0cmFjay5nZXQoJ3BhdGgnKSBvciB0cmFjay5nZXQoJ25hbWUnKSkNCiAgICAgICAgICAgIGlmIGx5cmljX2tleSBpbiBzZWxmLmx5cmljc19jYWNoZToNCiAgICAgICAgICAgICAgICBzZWxmLm9uX2x5cmljc19sb2FkZWQobHlyaWNfa2V5LCBzZWxmLmx5cmljc19jYWNoZVtseXJpY19rZXldKQ0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKHNlbGYsICdseXJpY193b3JrZXInKSBhbmQgZ2V0YXR0cihzZWxmLCAnbHlyaWNfd29ya2VyJykuaXNSdW5uaW5nKCk6DQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubHlyaWNfd29ya2VyLnF1aXQoKTsgc2VsZi5seXJpY193b3JrZXIud2FpdCgpDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgICAgICAgICAgICAgICAgICBwYXNzDQogICAgICAgICAgICAgICAgc2VsZi5seXJpY193b3JrZXIgPSBMeXJpY3NXb3JrZXIodHJhY2ssIHBhcmVudD1zZWxmKQ0KICAgICAgICAgICAgICAgIHNlbGYubHlyaWNfd29ya2VyLmZpbmlzaGVkLmNvbm5lY3Qoc2VsZi5vbl9seXJpY3NfbG9hZGVkKQ0KICAgICAgICAgICAgICAgIHNlbGYubHlyaWNfd29ya2VyLmVycm9yLmNvbm5lY3Qoc2VsZi5oYW5kbGVfd29ya2VyX2Vycm9yKQ0KICAgICAgICAgICAgICAgIHNlbGYubHlyaWNfd29ya2VyLnN0YXJ0KCkNCg0KICAgIGRlZiBoYW5kbGVfaW1hZ2VfZmluaXNoZWQoc2VsZiwgaW1hZ2UsIHVybCk6DQogICAgICAgIGlmIG5vdCBpbWFnZS5pc051bGwoKToNCiAgICAgICAgICAgICMgY2FjaGUgYW5kIHVwZGF0ZQ0KICAgICAgICAgICAgc2VsZi5jb3Zlcl9jYWNoZVt1cmxdID0gaW1hZ2UNCiAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhY2tncm91bmQoaW1hZ2UpDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICAjIGZhbGxiYWNrIHBsYWNlaG9sZGVyDQogICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgc2VsZi5iZ19sYWJlbC5zZXRQaXhtYXAoUVBpeG1hcCgiZGVmYXVsdF9jb3Zlci5wbmciKSkNCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgICAgICAgICAgc2VsZi5iZ19sYWJlbC5zZXRTdHlsZVNoZWV0KCJiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzOyIpDQoNCiAgICBkZWYgdXBkYXRlX2JhY2tncm91bmQoc2VsZiwgaW1hZ2UpOg0KICAgICAgICBpZiBub3QgaW1hZ2UuaXNOdWxsKCk6DQogICAgICAgICAgICBwaXhtYXAgPSBRUGl4bWFwLmZyb21JbWFnZShpbWFnZSkNCiAgICAgICAgICAgIHNlbGYuYmdfbGFiZWwuc2V0UGl4bWFwKHBpeG1hcCkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHNlbGYuYmdfbGFiZWwuc2V0U3R5bGVTaGVldCgiYmFja2dyb3VuZC1jb2xvcjogIzMzMzsiKQ0KDQogICAgZGVmIHRvZ2dsZV9wbGF5KHNlbGYpOg0KICAgICAgICBpZiBzZWxmLnBsYXllci5zdGF0ZSgpID09IFFNZWRpYVBsYXllci5QbGF5aW5nU3RhdGU6DQogICAgICAgICAgICBzZWxmLnBsYXllci5wYXVzZSgpDQogICAgICAgICAgICBzZWxmLmlzX3BsYXlpbmcgPSBGYWxzZQ0KICAgICAgICAgICAgc2VsZi5idG5fcGxheS5zZXRUZXh0KCLilrYiKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgc2VsZi5wbGF5ZXIucGxheSgpDQogICAgICAgICAgICBzZWxmLmlzX3BsYXlpbmcgPSBUcnVlDQogICAgICAgICAgICBzZWxmLmJ0bl9wbGF5LnNldFRleHQoIuKPuCIpDQoNCiAgICBkZWYgcGxheV9uZXh0KHNlbGYpOg0KICAgICAgICBpZiBub3Qgc2VsZi5wbGF5bGlzdDogcmV0dXJuDQogICAgICAgIG5leHRfaWR4ID0gKHNlbGYuY3VycmVudF9pbmRleCArIDEpICUgbGVuKHNlbGYucGxheWxpc3QpDQogICAgICAgIHNlbGYucGxheV90cmFjayhuZXh0X2lkeCkNCg0KICAgIGRlZiBwbGF5X3ByZXYoc2VsZik6DQogICAgICAgIGlmIG5vdCBzZWxmLnBsYXlsaXN0OiByZXR1cm4NCiAgICAgICAgcHJldl9pZHggPSAoc2VsZi5jdXJyZW50X2luZGV4IC0gMSkgaWYgc2VsZi5jdXJyZW50X2luZGV4ID4gMCBlbHNlIGxlbihzZWxmLnBsYXlsaXN0KSAtIDENCiAgICAgICAgc2VsZi5wbGF5X3RyYWNrKHByZXZfaWR4KQ0KDQogICAgZGVmIG9uX21lZGlhX3N0YXR1c19jaGFuZ2VkKHNlbGYsIHN0YXR1cyk6DQogICAgICAgIGlmIHN0YXR1cyA9PSBRTWVkaWFQbGF5ZXIuRW5kT2ZNZWRpYToNCiAgICAgICAgICAgIHNlbGYucGxheV9uZXh0KCkNCg0KICAgIGRlZiBvbl9wbGF5ZXJfZXJyb3Ioc2VsZiwgZXJyb3IpOg0KICAgICAgICBzZWxmLnNob3dfd2FybmluZygi5pKt5pS+6ZSZ6K+vIiwgZiLmkq3mlL7lmajplJnor686IHtzZWxmLnBsYXllci5lcnJvclN0cmluZygpfSIpDQogICAgICAgIFFUaW1lci5zaW5nbGVTaG90KDEwMDAsIHNlbGYucGxheV9uZXh0KQ0KDQogICAgZGVmIG9uX3Bvc2l0aW9uX2NoYW5nZWQoc2VsZiwgcG9zaXRpb24pOg0KICAgICAgICBpZiBub3Qgc2VsZi5zbGlkZXIuaXNTbGlkZXJEb3duKCk6DQogICAgICAgICAgICBzZWxmLnNsaWRlci5zZXRWYWx1ZShwb3NpdGlvbikNCiAgICAgICAgc2VsZi5sYmxfY3Vyci5zZXRUZXh0KHNlbGYuZm9ybWF0X3RpbWUocG9zaXRpb24pKQ0KICAgICAgICBzZWxmLnN5bmNfbHlyaWNzKHBvc2l0aW9uIC8gMTAwMC4wKQ0KDQogICAgZGVmIG9uX2R1cmF0aW9uX2NoYW5nZWQoc2VsZiwgZHVyYXRpb24pOg0KICAgICAgICBzZWxmLnNsaWRlci5zZXRSYW5nZSgwLCBkdXJhdGlvbikNCiAgICAgICAgc2VsZi5sYmxfdG90YWwuc2V0VGV4dChzZWxmLmZvcm1hdF90aW1lKGR1cmF0aW9uKSkNCg0KICAgIGRlZiBzZXRfcG9zaXRpb24oc2VsZiwgcG9zaXRpb24pOg0KICAgICAgICBzZWxmLnBsYXllci5zZXRQb3NpdGlvbihwb3NpdGlvbikNCg0KICAgIGRlZiBmb3JtYXRfdGltZShzZWxmLCBtcyk6DQogICAgICAgIHNlY29uZHMgPSAobXMgLy8gMTAwMCkgJSA2MA0KICAgICAgICBtaW51dGVzID0gKG1zIC8vIDYwMDAwKQ0KICAgICAgICByZXR1cm4gZiJ7bWludXRlczowMn06e3NlY29uZHM6MDJ9Ig0KDQogICAgIyAtLS0gTHlyaWNzIExvZ2ljIC0tLQ0KICAgIGRlZiBvbl9seXJpY3NfbG9hZGVkKHNlbGYsIHRyYWNrX2lkLCB0ZXh0KToNCiAgICAgICAgc2VsZi5seXJpY3NfZGF0YSA9IFtdDQogICAgICAgIHJlZ2V4ID0gcmUuY29tcGlsZShyJ1xbKFxkezJ9KTooXGR7Mn0pXC4oXGR7MiwzfSlcXSguKiknKQ0KICAgICAgICANCiAgICAgICAgbGluZXMgPSB0ZXh0LnNwbGl0KCdcbicpDQogICAgICAgIGZvciBsaW5lIGluIGxpbmVzOg0KICAgICAgICAgICAgbWF0Y2ggPSByZWdleC5tYXRjaChsaW5lKQ0KICAgICAgICAgICAgaWYgbWF0Y2g6DQogICAgICAgICAgICAgICAgbWludXRlcyA9IGludChtYXRjaC5ncm91cCgxKSkNCiAgICAgICAgICAgICAgICBzZWNvbmRzID0gaW50KG1hdGNoLmdyb3VwKDIpKQ0KICAgICAgICAgICAgICAgIG1zID0gaW50KG1hdGNoLmdyb3VwKDMpKQ0KICAgICAgICAgICAgICAgIGlmIGxlbihtYXRjaC5ncm91cCgzKSkgPT0gMjogbXMgKj0gMTANCiAgICAgICAgICAgICAgICB0aW1lX3NlYyA9IG1pbnV0ZXMgKiA2MCArIHNlY29uZHMgKyBtcyAvIDEwMDAuMA0KICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBtYXRjaC5ncm91cCg0KS5zdHJpcCgpDQogICAgICAgICAgICAgICAgaWYgY29udGVudDoNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5seXJpY3NfZGF0YS5hcHBlbmQoKHRpbWVfc2VjLCBjb250ZW50KSkNCiAgICAgICAgDQogICAgICAgICMgY2FjaGUgcmF3IGx5cmljcyB0ZXh0DQogICAgICAgIGtleSA9IHN0cih0cmFja19pZCkNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgc2VsZi5seXJpY3NfY2FjaGVba2V5XSA9IHRleHQNCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgICAgIHBhc3MNCg0KICAgICAgICBzZWxmLmx5cmljc19saXN0LmNsZWFyKCkNCiAgICAgICAgaWYgbm90IHNlbGYubHlyaWNzX2RhdGE6DQogICAgICAgICAgICBzZWxmLmx5cmljc19saXN0LmFkZEl0ZW0oIuaaguaXoOatjOivjSAvIOe6r+mfs+S5kCIpDQogICAgICAgICAgICByZXR1cm4NCiAgICAgICAgICAgIA0KICAgICAgICBmb3IgXywgY29udGVudCBpbiBzZWxmLmx5cmljc19kYXRhOg0KICAgICAgICAgICAgc2VsZi5seXJpY3NfbGlzdC5hZGRJdGVtKGNvbnRlbnQpDQogICAgICAgICAgICANCiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5seXJpY3NfbGlzdC5jb3VudCgpKToNCiAgICAgICAgICAgIGl0ID0gc2VsZi5seXJpY3NfbGlzdC5pdGVtKGkpDQogICAgICAgICAgICBpdC5zZXRUZXh0QWxpZ25tZW50KFF0LkFsaWduQ2VudGVyKQ0KICAgICAgICAgICAgIyBhcHBseSBkZWZhdWx0IGZvbnQgJiBjb2xvcg0KICAgICAgICAgICAgaXQuc2V0Rm9udChzZWxmLmx5cmljc19mb250KQ0KICAgICAgICAgICAgaXQuc2V0Rm9yZWdyb3VuZChzZWxmLmx5cmljc19jb2xvcikNCg0KICAgIGRlZiBzeW5jX2x5cmljcyhzZWxmLCBjdXJyZW50X3RpbWVfc2VjKToNCiAgICAgICAgaWYgbm90IHNlbGYubHlyaWNzX2RhdGE6IHJldHVybg0KICAgICAgICANCiAgICAgICAgYWN0aXZlX2lkeCA9IC0xDQogICAgICAgIGZvciBpLCAodGltZV92YWwsIF8pIGluIGVudW1lcmF0ZShzZWxmLmx5cmljc19kYXRhKToNCiAgICAgICAgICAgIGlmIHRpbWVfdmFsID4gY3VycmVudF90aW1lX3NlYzoNCiAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgYWN0aXZlX2lkeCA9IGkNCiAgICAgICAgICAgIA0KICAgICAgICBpZiBhY3RpdmVfaWR4ICE9IC0xOg0KICAgICAgICAgICAgc2VsZi5seXJpY3NfbGlzdC5zZXRDdXJyZW50Um93KGFjdGl2ZV9pZHgpDQogICAgICAgICAgICANCiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKHNlbGYubHlyaWNzX2xpc3QuY291bnQoKSk6DQogICAgICAgICAgICAgICAgaXRlbSA9IHNlbGYubHlyaWNzX2xpc3QuaXRlbShpKQ0KICAgICAgICAgICAgICAgIGlmIGkgPT0gYWN0aXZlX2lkeDoNCiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRGb3JlZ3JvdW5kKFFDb2xvcihzZWxmLmFjY2VudF9jb2xvcikpDQogICAgICAgICAgICAgICAgICAgIGZvbnQgPSBRRm9udChzZWxmLmx5cmljc19mb250KQ0KICAgICAgICAgICAgICAgICAgICBmb250LnNldEJvbGQoVHJ1ZSkNCiAgICAgICAgICAgICAgICAgICAgIyBzbGlnaHRseSBsYXJnZXIgZm9yIGFjdGl2ZQ0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICBmb250LnNldFBvaW50U2l6ZShtYXgoc2VsZi5seXJpY3NfZm9udC5wb2ludFNpemUoKSArIDQsIDE0KSkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQuc2V0UG9pbnRTaXplKDE2KQ0KICAgICAgICAgICAgICAgICAgICBpdGVtLnNldEZvbnQoZm9udCkNCiAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICBpdGVtLnNldEZvcmVncm91bmQoc2VsZi5seXJpY3NfY29sb3IpDQogICAgICAgICAgICAgICAgICAgIGZvbnQgPSBRRm9udChzZWxmLmx5cmljc19mb250KQ0KICAgICAgICAgICAgICAgICAgICBmb250LnNldEJvbGQoRmFsc2UpDQogICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0Rm9udChmb250KQ0KICAgICAgICAgICAgDQogICAgICAgICAgICBzZWxmLmx5cmljc19saXN0LnNjcm9sbFRvSXRlbShzZWxmLmx5cmljc19saXN0Lml0ZW0oYWN0aXZlX2lkeCksIFFMaXN0V2lkZ2V0LlBvc2l0aW9uQXRDZW50ZXIpDQoNCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6DQogICAgYXBwID0gUUFwcGxpY2F0aW9uKHN5cy5hcmd2KQ0KICAgIHBsYXllciA9IE11c2ljUGxheWVyKCkNCiAgICBwbGF5ZXIuc2hvdygpDQogICAgc3lzLmV4aXQoYXBwLmV4ZWNfKCkpDQo='
BIND_CPU='UNBOUND'
BIND_DISK='UNBOUND'
BIND_MAC='12ce5104cc70'
BIND_CWD='UNBOUND'
USE_EXPIRY=False
EXPIRY_DATE=''

# --- helper functions ---
def hex2(b):
    return bytes.fromhex(b)

def obfuscate_py(pwd):
    # mirror Java obfuscation: XOR with 0x5A then +3 on bytes, then hex
    bs = pwd.encode('utf-8')
    out = bytearray()
    for i,b in enumerate(bs):
        out.append(((b ^ 0x5A) + 3) & 0xFF)
    return out.hex()

def check_password():
    lockfile = os.path.join(os.path.dirname(__file__), '.lock_'+os.path.basename(__file__))
    # simple lockfile format: failed_count|unlock_epoch
    failed=0; unlock=0
    if os.path.exists(lockfile):
        try:
            with open(lockfile,'r') as f:
                t=f.read().split('|')
                if len(t)>=1 and t[0]: failed=int(t[0])
                if len(t)>=2 and t[1]: unlock=int(t[1])
        except Exception:
            pass
    now=int(time.time())
    if unlock>now:
        print('程序已锁定，请稍后再试')
        sys.exit(1)
    pwd = getpass.getpass('请输入密码: ')
    obf = obfuscate_py(pwd)
    m = hashlib.sha256()
    m.update(bytes.fromhex(SALT_HEX))
    m.update(bytes.fromhex(obf))
    if m.hexdigest() == EXPECTED_HASH:
        try:
            with open(lockfile,'w') as f: f.write('0|0')
        except Exception: pass
        return True
    else:
        failed += 1
        if failed >= LOCK_THRESHOLD:
            unlock = now + LOCK_MINUTES*60
            try:
                with open(lockfile,'w') as f: f.write(str(failed)+'|'+str(unlock))
            except Exception: pass
            print('错误次数过多，已锁定')
            sys.exit(1)
        else:
            try:
                with open(lockfile,'w') as f: f.write(str(failed)+'|0')
            except Exception: pass
            # show remaining attempts
            try:
                rem = LOCK_THRESHOLD - failed
            except Exception:
                rem = 0
            print('密码错误，剩余%d次尝试' % (rem))
            return False

def check_time():
    # local time check
    if USE_EXPIRY and EXPIRY_DATE:
        try:
            exp = datetime.datetime.fromisoformat(EXPIRY_DATE)
            if datetime.datetime.now() > exp:
                print('当前已过期，请联系作者')
                sys.exit(1)
        except Exception as e:
            pass
    # network time check (best-effort)
    try:
        with urllib.request.urlopen('http://worldtimeapi.org/api/ip', timeout=5) as r:
            import json
            data = json.load(r)
            nt = data.get('unixtime')
            if nt and USE_EXPIRY and EXPIRY_DATE:
                exp = int(datetime.datetime.fromisoformat(EXPIRY_DATE).timestamp())
                if nt > exp:
                    print('当前已过期，请联系作者')
                    sys.exit(1)
    except Exception:
        pass

def check_bindings():
    # check MAC - collect multiple candidates and compare normalized forms
    mac_candidates = set()
    try:
        m = hex(uuid.getnode())[2:]
        if m:
            mac_candidates.add(m.lower().rjust(12,'0'))
    except Exception:
        pass
    # try platform tools for extra MACs
    try:
        if os.name=='nt':
            out = subprocess.check_output(['getmac'], stderr=subprocess.DEVNULL).decode(errors='ignore')
        else:
            # ip link or ifconfig fallback
            try:
                out = subprocess.check_output(['ip','link'], stderr=subprocess.DEVNULL).decode(errors='ignore')
            except Exception:
                out = subprocess.check_output(['ifconfig','-a'], stderr=subprocess.DEVNULL).decode(errors='ignore')
        import re
        for mo in re.findall(r'([0-9a-fA-F]{2}([:-]?)){5}[0-9a-fA-F]{2}', out):
            raw = mo[0]
            norm = re.sub(r'[^0-9a-fA-F]','', raw).lower().rjust(12,'0')
            mac_candidates.add(norm)
    except Exception:
        pass
    try:
        bind_norm = BIND_MAC.lower().rjust(12,'0')
    except Exception:
        bind_norm = BIND_MAC.lower()
    # debug: show detected candidates when mismatch occurs
    if BIND_MAC!='UNBOUND' and bind_norm not in mac_candidates:
        print('绑定校验失败: MAC')
        try:
            print('期望:', bind_norm, '检测到的 MAC:', ','.join(sorted(mac_candidates)))
        except Exception:
            pass
        terminate('绑定校验失败: MAC',1)
    if BIND_CWD!='UNBOUND' and os.path.abspath(os.getcwd())!=os.path.abspath(BIND_CWD):
        print('绑定校验失败: 运行目录')
        terminate('绑定校验失败: 运行目录',1)
    # CPU/DISK best-effort: skip strict checks on non-windows
    if BIND_CPU!='UNBOUND' or BIND_DISK!='UNBOUND':
        try:
            if os.name=='nt':
                # try wmic
                pass
        except Exception:
            pass

def detect_reverse_tools():
    suspects=['ida64.exe','ida.exe','ollydbg.exe','x64dbg.exe','frida-server','uncompyle6','pyinstxtractor.py','ghidra']
    try:
        if os.name=='nt':
            out = subprocess.check_output(['tasklist'], stderr=subprocess.DEVNULL).decode(errors='ignore').lower()
        else:
            out = subprocess.check_output(['ps','-A'], stderr=subprocess.DEVNULL).decode(errors='ignore').lower()
        for s in suspects:
            if s.lower() in out:
                print('检测到逆向工具:', s)
                sys.exit(1)
    except Exception:
        pass

def check_integrity():
    try:
        # read as text and normalize the INTEGRITY line to mask placeholder before hashing
        with open(__file__,'r', encoding='utf-8', errors='ignore') as f:
            s = f.read()
        import re
        s_for_hash = re.sub(r"INTEGRITY='[0-9a-fA-F]+'", "INTEGRITY='__INTEGRITY_MASK__'", s)
        h = hashlib.sha256(s_for_hash.encode('utf-8')).hexdigest()
        if h != INTEGRITY:
            print('当前检测被篡改,请不要篡改代码')
            sys.exit(1)
    except Exception:
        pass

# main flow (wrapped to catch unexpected exceptions and keep console open)
try:
    check_integrity()
    detect_reverse_tools()
    check_time()
    check_bindings()
    # friendly messages
    print('当前代码已加密，请输入密码')
    ok=False
    for _ in range(LOCK_THRESHOLD):
        if check_password():
            ok=True; break

    if not ok:
        terminate('密码错误，程序退出',1)

    # restore payload and execute
    code = base64.b64decode(PAYLOAD_B64).decode('utf-8')
    exec(compile(code, '<payload>', 'exec'))
except Exception as e:
    import traceback
    traceback.print_exc()
    terminate('异常退出: %s' % (e),1)
